# Chat History Database Specification

## ðŸŽ¯ Overview

This document specifies the database schema and operations for persisting conversation history in Phase 3. Chat history enables stateless conversation management and context continuity across sessions.

---

## ðŸ“Š Database Schema

### ChatHistory Table

**Table Name:** `chat_history`

**Purpose:** Store all conversation messages between users and the AI assistant

**Schema Definition (SQLModel):**

```python
from sqlmodel import SQLModel, Field, Column, JSON
from datetime import datetime
from typing import Optional, Dict, Any

class ChatHistory(SQLModel, table=True):
    """
    Chat history model for storing conversation messages
    """
    __tablename__ = "chat_history"

    # Primary Key
    id: Optional[int] = Field(default=None, primary_key=True)

    # Foreign Keys
    user_id: int = Field(foreign_key="users.id", index=True, nullable=False)

    # Session Management
    session_id: str = Field(index=True, nullable=False, max_length=100)

    # Message Content
    role: str = Field(nullable=False, max_length=20)  # "user", "assistant", "system"
    content: str = Field(nullable=False)  # Message text

    # Metadata
    metadata: Optional[Dict[str, Any]] = Field(
        default=None,
        sa_column=Column(JSON)
    )  # Store tool calls, tokens used, etc.

    # Timestamps
    timestamp: datetime = Field(
        default_factory=datetime.utcnow,
        nullable=False,
        index=True
    )

    # Soft Delete
    is_deleted: bool = Field(default=False, nullable=False)

    class Config:
        json_schema_extra = {
            "example": {
                "user_id": 123,
                "session_id": "sess_abc123xyz",
                "role": "user",
                "content": "Show me my tasks",
                "metadata": {
                    "client_ip": "192.168.1.1",
                    "user_agent": "Mozilla/5.0..."
                },
                "timestamp": "2025-12-18T10:30:00Z",
                "is_deleted": False
            }
        }
```

### SQL DDL

```sql
CREATE TABLE chat_history (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    session_id VARCHAR(100) NOT NULL,
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,
    metadata JSONB,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    is_deleted BOOLEAN NOT NULL DEFAULT FALSE,

    -- Indexes for performance
    INDEX idx_chat_history_user_id (user_id),
    INDEX idx_chat_history_session_id (session_id),
    INDEX idx_chat_history_timestamp (timestamp),
    INDEX idx_chat_history_user_session (user_id, session_id, timestamp DESC)
);

-- Composite index for common query pattern
CREATE INDEX idx_chat_history_lookup
ON chat_history(user_id, session_id, is_deleted, timestamp DESC);

-- Add comment
COMMENT ON TABLE chat_history IS 'Stores conversation messages for stateless chat functionality';
```

---

## ðŸ”‘ Schema Design Decisions

### Field Descriptions

| Field | Type | Purpose | Constraints |
|-------|------|---------|-------------|
| `id` | INTEGER | Primary key | Auto-increment |
| `user_id` | INTEGER | Link to user | FK to users.id, indexed |
| `session_id` | VARCHAR(100) | Group related messages | Indexed, generated by frontend |
| `role` | VARCHAR(20) | Message sender type | ENUM: user/assistant/system |
| `content` | TEXT | Message text | Non-null, unlimited length |
| `metadata` | JSONB | Additional context | Optional, flexible structure |
| `timestamp` | TIMESTAMPTZ | When message was sent | Indexed, auto-generated |
| `is_deleted` | BOOLEAN | Soft delete flag | Default false |

### Session ID Format

**Format:** `sess_{timestamp}_{random}`

**Example:** `sess_1702890000_a7f3k9x2`

**Generation (Frontend):**
```javascript
function generateSessionId() {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 10);
    return `sess_${timestamp}_${random}`;
}
```

**Properties:**
- Unique per conversation
- Sortable by creation time
- Client-generated, stored in localStorage
- Persists across page reloads

### Role Types

| Role | Description | Who Sends |
|------|-------------|-----------|
| `user` | User's message | User via frontend |
| `assistant` | AI's response | OpenAI Agent |
| `system` | System notifications | Backend (e.g., session start) |

### Metadata Structure

**Purpose:** Store additional context without schema changes

**Common Fields:**
```json
{
  "tool_calls": [
    {
      "tool": "create_todo",
      "parameters": {"title": "Buy milk"},
      "result": {"success": true, "todo_id": 456}
    }
  ],
  "tokens_used": 150,
  "response_time_ms": 1250,
  "model": "gpt-4-turbo",
  "intent": "CREATE_TODO",
  "confidence": 0.95,
  "client_info": {
    "ip": "192.168.1.1",
    "user_agent": "Mozilla/5.0...",
    "device": "desktop"
  },
  "error": null
}
```

**Assistant Message Metadata:**
```json
{
  "tool_calls": [...],
  "tokens_used": 200,
  "response_time_ms": 1500,
  "model": "gpt-4-turbo"
}
```

**User Message Metadata:**
```json
{
  "client_info": {
    "ip": "192.168.1.1",
    "user_agent": "Chrome/120.0",
    "device": "desktop"
  }
}
```

---

## ðŸ” Database Queries

### Query 1: Load Recent Chat History

**Purpose:** Load conversation context for AI agent

**SQL:**
```sql
SELECT id, role, content, metadata, timestamp
FROM chat_history
WHERE user_id = $1
  AND session_id = $2
  AND is_deleted = FALSE
ORDER BY timestamp DESC
LIMIT $3;
```

**SQLModel:**
```python
async def load_chat_history(
    session: AsyncSession,
    user_id: int,
    session_id: str,
    limit: int = 20
) -> list[ChatHistory]:
    """
    Load recent chat history for a session
    """
    statement = (
        select(ChatHistory)
        .where(
            ChatHistory.user_id == user_id,
            ChatHistory.session_id == session_id,
            ChatHistory.is_deleted == False
        )
        .order_by(ChatHistory.timestamp.desc())
        .limit(limit)
    )

    result = await session.execute(statement)
    messages = result.scalars().all()

    # Return in chronological order (oldest first)
    return list(reversed(messages))
```

**Usage:**
```python
# Load last 20 messages for context
history = await load_chat_history(
    session=db_session,
    user_id=123,
    session_id="sess_abc123",
    limit=20
)

# Format for AI agent
messages = [
    {"role": msg.role, "content": msg.content}
    for msg in history
]
```

### Query 2: Save New Message

**Purpose:** Persist a new chat message

**SQLModel:**
```python
async def save_message(
    session: AsyncSession,
    user_id: int,
    session_id: str,
    role: str,
    content: str,
    metadata: Optional[Dict] = None
) -> ChatHistory:
    """
    Save a new chat message
    """
    message = ChatHistory(
        user_id=user_id,
        session_id=session_id,
        role=role,
        content=content,
        metadata=metadata
    )

    session.add(message)
    await session.commit()
    await session.refresh(message)

    return message
```

**Usage:**
```python
# Save user message
user_msg = await save_message(
    session=db_session,
    user_id=123,
    session_id="sess_abc123",
    role="user",
    content="Show me my tasks",
    metadata={"client_info": {"ip": "192.168.1.1"}}
)

# Save assistant response
assistant_msg = await save_message(
    session=db_session,
    user_id=123,
    session_id="sess_abc123",
    role="assistant",
    content="You have 3 pending tasks...",
    metadata={
        "tool_calls": [{"tool": "list_todos", "result": {...}}],
        "tokens_used": 200
    }
)
```

### Query 3: Get User Sessions

**Purpose:** List all conversation sessions for a user

**SQL:**
```sql
SELECT DISTINCT session_id,
       MIN(timestamp) as started_at,
       MAX(timestamp) as last_message_at,
       COUNT(*) as message_count
FROM chat_history
WHERE user_id = $1
  AND is_deleted = FALSE
GROUP BY session_id
ORDER BY last_message_at DESC
LIMIT $2;
```

**SQLModel:**
```python
from sqlalchemy import func

async def get_user_sessions(
    session: AsyncSession,
    user_id: int,
    limit: int = 50
) -> list[Dict]:
    """
    Get all sessions for a user with summary info
    """
    statement = (
        select(
            ChatHistory.session_id,
            func.min(ChatHistory.timestamp).label('started_at'),
            func.max(ChatHistory.timestamp).label('last_message_at'),
            func.count(ChatHistory.id).label('message_count')
        )
        .where(
            ChatHistory.user_id == user_id,
            ChatHistory.is_deleted == False
        )
        .group_by(ChatHistory.session_id)
        .order_by(desc('last_message_at'))
        .limit(limit)
    )

    result = await session.execute(statement)
    sessions = [
        {
            "session_id": row.session_id,
            "started_at": row.started_at,
            "last_message_at": row.last_message_at,
            "message_count": row.message_count
        }
        for row in result
    ]

    return sessions
```

### Query 4: Delete Session (Soft Delete)

**Purpose:** Mark all messages in a session as deleted

**SQLModel:**
```python
async def delete_session(
    session: AsyncSession,
    user_id: int,
    session_id: str
) -> int:
    """
    Soft delete all messages in a session
    Returns number of messages deleted
    """
    statement = (
        update(ChatHistory)
        .where(
            ChatHistory.user_id == user_id,
            ChatHistory.session_id == session_id,
            ChatHistory.is_deleted == False
        )
        .values(is_deleted=True)
    )

    result = await session.execute(statement)
    await session.commit()

    return result.rowcount
```

### Query 5: Get Session Summary

**Purpose:** Get first message preview for session list

**SQLModel:**
```python
async def get_session_summary(
    session: AsyncSession,
    user_id: int,
    session_id: str
) -> Optional[Dict]:
    """
    Get summary of a session including first user message
    """
    # Get first user message
    first_msg_statement = (
        select(ChatHistory)
        .where(
            ChatHistory.user_id == user_id,
            ChatHistory.session_id == session_id,
            ChatHistory.role == "user",
            ChatHistory.is_deleted == False
        )
        .order_by(ChatHistory.timestamp.asc())
        .limit(1)
    )

    result = await session.execute(first_msg_statement)
    first_message = result.scalar_one_or_none()

    if not first_message:
        return None

    # Get stats
    stats_statement = (
        select(
            func.count(ChatHistory.id).label('total_messages'),
            func.max(ChatHistory.timestamp).label('last_updated')
        )
        .where(
            ChatHistory.user_id == user_id,
            ChatHistory.session_id == session_id,
            ChatHistory.is_deleted == False
        )
    )

    stats_result = await session.execute(stats_statement)
    stats = stats_result.one()

    return {
        "session_id": session_id,
        "preview": first_message.content[:100],  # First 100 chars
        "started_at": first_message.timestamp,
        "last_updated": stats.last_updated,
        "message_count": stats.total_messages
    }
```

### Query 6: Cleanup Old Sessions

**Purpose:** Hard delete old, soft-deleted sessions (maintenance)

**SQL:**
```sql
DELETE FROM chat_history
WHERE is_deleted = TRUE
  AND timestamp < NOW() - INTERVAL '90 days';
```

**SQLModel:**
```python
from datetime import timedelta

async def cleanup_old_deleted_sessions(
    session: AsyncSession,
    days: int = 90
) -> int:
    """
    Permanently delete soft-deleted messages older than specified days
    """
    cutoff_date = datetime.utcnow() - timedelta(days=days)

    statement = (
        delete(ChatHistory)
        .where(
            ChatHistory.is_deleted == True,
            ChatHistory.timestamp < cutoff_date
        )
    )

    result = await session.execute(statement)
    await session.commit()

    return result.rowcount
```

---

## ðŸ”„ Data Flow

### Message Persistence Flow

```
User sends message
    â†“
Frontend â†’ POST /chat
    â†“
Backend receives request
    â†“
1. Validate JWT â†’ Extract user_id
2. Load chat history from DB (last 20 messages)
    â†“
3. Save user message to DB
    â†“
4. Build context for AI agent
5. Call OpenAI Agent with context + new message
    â†“
6. Agent processes and returns response
    â†“
7. Save assistant message to DB
    â†“
8. Return response to frontend
    â†“
Frontend displays message
```

### Database Operations per Request

```python
async def handle_chat_request(
    user_id: int,
    session_id: str,
    user_message: str,
    db_session: AsyncSession
):
    """
    Handle a chat request with database operations
    """
    # 1. Load history (READ)
    history = await load_chat_history(
        db_session, user_id, session_id, limit=20
    )

    # 2. Save user message (WRITE)
    await save_message(
        db_session,
        user_id=user_id,
        session_id=session_id,
        role="user",
        content=user_message,
        metadata={"timestamp": datetime.utcnow().isoformat()}
    )

    # 3. Call AI agent
    agent_response = await call_ai_agent(
        user_id=user_id,
        history=history,
        message=user_message
    )

    # 4. Save assistant message (WRITE)
    await save_message(
        db_session,
        user_id=user_id,
        session_id=session_id,
        role="assistant",
        content=agent_response["content"],
        metadata=agent_response.get("metadata", {})
    )

    return agent_response
```

---

## ðŸ“ˆ Performance Optimization

### Indexing Strategy

**Primary Indexes:**
```sql
-- Single column indexes
CREATE INDEX idx_chat_history_user_id ON chat_history(user_id);
CREATE INDEX idx_chat_history_session_id ON chat_history(session_id);
CREATE INDEX idx_chat_history_timestamp ON chat_history(timestamp);

-- Composite index for common query
CREATE INDEX idx_chat_history_lookup
ON chat_history(user_id, session_id, is_deleted, timestamp DESC);
```

**Why these indexes?**
- `user_id`: Filter by user in all queries
- `session_id`: Filter by session in all queries
- `timestamp`: Sort messages chronologically
- Composite: Optimizes the most common query pattern

### Query Performance Targets

| Query | Target | P95 | P99 |
|-------|--------|-----|-----|
| Load history (20 msgs) | <50ms | 100ms | 200ms |
| Save message | <30ms | 50ms | 100ms |
| Get user sessions | <100ms | 200ms | 400ms |
| Delete session | <50ms | 100ms | 200ms |

### Optimization Techniques

**1. Connection Pooling:**
```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession

engine = create_async_engine(
    DATABASE_URL,
    pool_size=20,
    max_overflow=10,
    pool_pre_ping=True,
    echo=False
)
```

**2. Limit History Load:**
```python
# Only load what's needed (last 20 messages)
# Don't load entire conversation history
MAX_CONTEXT_MESSAGES = 20
```

**3. Batch Saves (Future Enhancement):**
```python
# Save user + assistant messages in one transaction
async def save_message_pair(
    session: AsyncSession,
    user_msg: ChatHistory,
    assistant_msg: ChatHistory
):
    session.add_all([user_msg, assistant_msg])
    await session.commit()
```

**4. Read Replicas (Future Enhancement):**
```python
# Read from replica for history loads
# Write to primary for new messages
```

---

## ðŸ” Security and Privacy

### Data Access Control

**Rule:** Users can only access their own chat history

**Enforcement:**
```python
# Always include user_id in WHERE clause
async def load_chat_history(user_id: int, session_id: str):
    statement = select(ChatHistory).where(
        ChatHistory.user_id == user_id,  # Required
        ChatHistory.session_id == session_id
    )
    # This ensures user A cannot load user B's messages
```

### Data Retention Policy

**Retention Rules:**
- Active sessions: Keep indefinitely
- Soft-deleted sessions: Keep for 90 days
- After 90 days: Permanently delete soft-deleted messages

**Implementation:**
```python
# Run daily cleanup job
async def daily_cleanup_job():
    await cleanup_old_deleted_sessions(days=90)
```

### PII Handling

**Sensitive Data in Messages:**
- Todo content may contain personal information
- Chat messages stored as-is
- Comply with GDPR/CCPA requirements

**User Data Export:**
```python
async def export_user_data(user_id: int) -> Dict:
    """
    Export all user data for GDPR compliance
    """
    sessions = await get_user_sessions(user_id, limit=None)

    export = {
        "user_id": user_id,
        "sessions": []
    }

    for session_info in sessions:
        messages = await load_chat_history(
            user_id,
            session_info["session_id"],
            limit=None
        )
        export["sessions"].append({
            "session_id": session_info["session_id"],
            "messages": [
                {
                    "role": m.role,
                    "content": m.content,
                    "timestamp": m.timestamp.isoformat()
                }
                for m in messages
            ]
        })

    return export
```

**User Data Deletion:**
```python
async def delete_user_data(user_id: int):
    """
    Permanently delete all user chat history
    """
    statement = delete(ChatHistory).where(
        ChatHistory.user_id == user_id
    )
    await session.execute(statement)
    await session.commit()
```

---

## ðŸ§ª Testing Strategy

### Test Data Setup

```python
import pytest
from sqlmodel import create_engine, Session
from datetime import datetime, timedelta

@pytest.fixture
def test_messages():
    """Create test chat messages"""
    user_id = 123
    session_id = "sess_test_123"

    messages = [
        ChatHistory(
            user_id=user_id,
            session_id=session_id,
            role="user",
            content="Show my tasks",
            timestamp=datetime.utcnow() - timedelta(minutes=10)
        ),
        ChatHistory(
            user_id=user_id,
            session_id=session_id,
            role="assistant",
            content="You have 3 tasks...",
            timestamp=datetime.utcnow() - timedelta(minutes=9)
        ),
        ChatHistory(
            user_id=user_id,
            session_id=session_id,
            role="user",
            content="Add buy milk",
            timestamp=datetime.utcnow() - timedelta(minutes=5)
        ),
        ChatHistory(
            user_id=user_id,
            session_id=session_id,
            role="assistant",
            content="I've added 'Buy milk'",
            timestamp=datetime.utcnow() - timedelta(minutes=4)
        )
    ]

    return messages
```

### Unit Tests

```python
@pytest.mark.asyncio
async def test_load_chat_history(db_session, test_messages):
    """Test loading chat history"""
    # Insert test messages
    for msg in test_messages:
        db_session.add(msg)
    await db_session.commit()

    # Load history
    history = await load_chat_history(
        db_session, user_id=123, session_id="sess_test_123", limit=20
    )

    assert len(history) == 4
    assert history[0].role == "user"
    assert history[0].content == "Show my tasks"

@pytest.mark.asyncio
async def test_save_message(db_session):
    """Test saving a message"""
    message = await save_message(
        db_session,
        user_id=123,
        session_id="sess_test_456",
        role="user",
        content="Test message",
        metadata={"test": True}
    )

    assert message.id is not None
    assert message.content == "Test message"
    assert message.metadata["test"] == True

@pytest.mark.asyncio
async def test_user_isolation(db_session):
    """Test that users can't access other users' messages"""
    # Create messages for two users
    await save_message(db_session, 123, "sess_1", "user", "User 123 msg")
    await save_message(db_session, 456, "sess_2", "user", "User 456 msg")

    # User 123 should only see their messages
    history = await load_chat_history(db_session, 123, "sess_1")
    assert len(history) == 1
    assert history[0].content == "User 123 msg"

    # User 456 should only see their messages
    history = await load_chat_history(db_session, 456, "sess_2")
    assert len(history) == 1
    assert history[0].content == "User 456 msg"

@pytest.mark.asyncio
async def test_soft_delete(db_session, test_messages):
    """Test soft delete functionality"""
    for msg in test_messages:
        db_session.add(msg)
    await db_session.commit()

    # Delete session
    count = await delete_session(db_session, 123, "sess_test_123")
    assert count == 4

    # Messages should not appear in normal queries
    history = await load_chat_history(db_session, 123, "sess_test_123")
    assert len(history) == 0

    # But they still exist in database
    all_msgs = await db_session.execute(
        select(ChatHistory).where(ChatHistory.session_id == "sess_test_123")
    )
    assert len(all_msgs.scalars().all()) == 4
```

### Performance Tests

```python
@pytest.mark.performance
async def test_load_history_performance(db_session):
    """Test that loading history is fast"""
    # Insert 1000 messages
    for i in range(1000):
        await save_message(
            db_session, 123, "sess_perf", "user", f"Message {i}"
        )

    # Measure load time
    import time
    start = time.time()
    history = await load_chat_history(db_session, 123, "sess_perf", limit=20)
    elapsed = time.time() - start

    assert len(history) == 20
    assert elapsed < 0.1  # Should be under 100ms
```

---

## ðŸ”„ Migration Scripts

### Initial Migration

```python
"""Create chat_history table

Revision ID: 003
Revises: 002
Create Date: 2025-12-18
"""

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import JSONB

def upgrade():
    op.create_table(
        'chat_history',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('user_id', sa.Integer(), nullable=False),
        sa.Column('session_id', sa.String(100), nullable=False),
        sa.Column('role', sa.String(20), nullable=False),
        sa.Column('content', sa.Text(), nullable=False),
        sa.Column('metadata', JSONB, nullable=True),
        sa.Column('timestamp', sa.TIMESTAMP(timezone=True), nullable=False, server_default=sa.func.now()),
        sa.Column('is_deleted', sa.Boolean(), nullable=False, server_default='false'),
        sa.PrimaryKeyConstraint('id'),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
        sa.CheckConstraint("role IN ('user', 'assistant', 'system')", name='check_role')
    )

    # Create indexes
    op.create_index('idx_chat_history_user_id', 'chat_history', ['user_id'])
    op.create_index('idx_chat_history_session_id', 'chat_history', ['session_id'])
    op.create_index('idx_chat_history_timestamp', 'chat_history', ['timestamp'])
    op.create_index(
        'idx_chat_history_lookup',
        'chat_history',
        ['user_id', 'session_id', 'is_deleted', sa.text('timestamp DESC')]
    )

def downgrade():
    op.drop_index('idx_chat_history_lookup', table_name='chat_history')
    op.drop_index('idx_chat_history_timestamp', table_name='chat_history')
    op.drop_index('idx_chat_history_session_id', table_name='chat_history')
    op.drop_index('idx_chat_history_user_id', table_name='chat_history')
    op.drop_table('chat_history')
```

---

## ðŸ“‹ Implementation Checklist

- [ ] Create `chat_history` table with all fields
- [ ] Add foreign key to `users` table
- [ ] Create all indexes for performance
- [ ] Implement `load_chat_history` query
- [ ] Implement `save_message` mutation
- [ ] Implement `get_user_sessions` query
- [ ] Implement `delete_session` (soft delete)
- [ ] Implement `cleanup_old_deleted_sessions` maintenance job
- [ ] Add user data export for GDPR compliance
- [ ] Add user data deletion for GDPR compliance
- [ ] Write unit tests for all operations
- [ ] Write performance tests
- [ ] Set up daily cleanup cron job
- [ ] Document data retention policy
- [ ] Configure database connection pooling

---

## ðŸ”— Related Specifications

- [../features/chatbot.md](../features/chatbot.md) - Features using chat history
- [../agents/todo-agent.md](../agents/todo-agent.md) - Agent using context from history
- [../api/mcp-tools.md](../api/mcp-tools.md) - Tools called during conversations
- [../../CLAUDE.md](../../CLAUDE.md) - Project constitution

---

**Status:** Draft - Ready for Review
**Last Updated:** 2025-12-18
